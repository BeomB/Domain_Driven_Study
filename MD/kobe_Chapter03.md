### 애그리거트

도메인을 나눌때는 상위 수준의 모델에서 정리를 진행해야, 개념을 파악하는데 시간이 오래 걸리지 않는다.

바로 개별 객체 수준에서 모델을 바라보면, 상위 수준에서 관계를 파악하기 어렵다.

ex) 시큐어 → 국내 결제, 해외 결제, 간편 결제 0  — 시큐어 → 국민카드, 비자 카드, 카카오페이 X
백 개 이상의 테이블을 ERD로 정리하면 보기 복잡함과 같다.

상위 수준의 관계를 파악하기 어렵다는 뜻은 코드를 변경하고 확장하는것이 어렵다는 것을 뜻한다.

상위 수준의 관계를 쉽게 파악할 수 있도록 객체간의 관계를 군으로 묶은 것을 “애그리거트”라 한다.

애그리거트는 객체를 더 큰 수준의 묶음으로 관리하기 때문에 도메인을 단순한 구조로 묶어준다.
복잡도가 낮아지는 만큼 도메인을 확장하고, 변경하는 데 필요한 노력이 줄어든다.

- 하나의 애그리거트에 묶어진 객체들은 생성과 제거를 함께 해야한다.
- 애그리거트는 독립된 묶음으로, 다른 애그리거트에 영향을 끼치지 않는다.(재스퍼한테 물어보기)
- 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다. ( 주문 정보, 배송 정보)

💡 ”A가 B를 갖는다" 라는 요구사항이 있다고 해서 이것이 애그리거트에 속한다는 것은 아니다.
( 제품과 리뷰 관계 → 제품이 생성된다고 리뷰가 생성되는 것이 아니기 때문에 같은 애그리거트 X )

처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만, 도메인 규칙을 이해할수록 애그리거트의 실제 크기는 준다. → 한 개의 애그리거트는 한 개의 엔티티 객체만 갖는 경우가 많다.

질문 → transact_table, transcat_web table, settlement_table, settlemet_web table → ??????

### 애그리거트 루트

- Order 엔티티는 totalAmounts를 가지고 있다.
- quantity와 price를 가지고있는 OrderLine 밸류

구매 상품 개수를 변경하면 OrderLine의 quantity를 변경, totalAmounts도 변경해야한다.  → 도메인 규칙

### 도메인 규칙과 일관성

애그리거트는 여러 객체로 구성되기 때문에, 애그리거트의 모든 객체가 정상 상태를 가져야한다.
모든 객체를 정상 상태로 하기 위한 책임을 가지는 애그리거트가 애그리거트 루트이다.

- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접적, 혹은 간접적으로 속하게 된다.
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- 애그리거트 루트는 배송지 변경, 상품 변경과 같은 기능을 제공하고, 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다. → 애그리거트 루트의 코드 길이가 길어짐..?
- 애그리거트 외부에서 애그리거트의 속한 객체를 직접 변경하면 안 된다.
- set메서드를 public으로 X , 밸류 타입은 불변으로 구현한다.

```java
ShippingInfo shippingInfo = order.getShippingInfo();
shippingInfo.setAddress("인천 남동구"); -> 밸류(ShippingInfo가 불변이면 컴파일 에러!)
```

밸류의 값이 바뀌게 하려면 new를 이용해 새로운 밸류 타입 객체를 생성 후 변경해야한다. → 일관성 유지

### 애그리거트 루트의 기능 구현

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.

- Order은 총 주문 금액을 구하기 위해서 OrderLine 목록을 사용한다.
- Member는 암호를 변경하기 위해 Password 객체에 암호가 일치한지 확인한다.

애그리거트 루트는 상태 변경을 위임하기도 한다.

```java
public class Order {  //....

private OrderLines orderLines;
...
orderLines.changeOrderLines(newLines);
// 애그리거트 루트에서 OrderLines를 이용해 상태 변경
}
```

- 외부에서 객체의 값을 바꿀 수 없게 하기 위해서는 불변 객체를 이용하거나 protected를 사용해서 외부에서 변경 할 수 없도록 지정해야한다.

### 트랜잭션 범위

트랜잭션 범위는 작을수록 좋다. DB의 예와 같이 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.

한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것이다.

if) 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하게 된다면 결합도 증가.

부득이 하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 않고, 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.

### 리포지터리와 애그리거트