### 에그리거트와 트랜잭션

한 주문 애그리거트에 대해 운영자가 배송 상태로 변경할 때 사용자가 배송지 주소를 바꾸면 어떻게 될까?

하나의 트랜잭션 마다 리포지터리는 새로운 애그리거트 객체를 생설하기 때문에 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.

운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트지만, 물리적으로 서로 다른 애그리거트 객체를 사용한다. 그렇게 때문에 운영자가 스레드와 고객 스레드는 서로 상이하기 때문에 서로에게 영향을 주지 않는다.

스레드는 트랜잭션을 커밋할 때 DB에 반영하게 되는데, 이러한 이유로 애그리거트의 일관성이 깨지게 된다.

일관성 문제를 깨지지 않게 하기 위해서, 두 가지 중 하나를 해야한다.

- 운영자가 배송지 정보를 조회하고, 상태를 변경하는 동안, 고객이 애그리거트를 수정 못하게 막는다.
- 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

위 두 가지 방법은 애그리거트 자체의 트랜잭션과 관련이 있는데, DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다. - 선점, 비선점

### 선점 잠금

선점 잠금이란, 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식. - 스레드 1이 에그리거트를 구하게 되면, 에그리거트 2는 잠금을 해제할 때까지 블로킹된다. 스레드 1이 에그리거트를 수정하고 트랜잭션을 커밋 하면 그 때 잠금을 해제하고, 대기하고 있던 스레드2가 에그리거트에 접근하게 된다.

배송지 변경의 예를 대입했을 때 운영자가 선점 잠금 형식으로 애그리거트를 구하면 운영자가 잠금을 해제할 때 까지 고객 스레드는 대기 상태가 된다. 운영자가 배송 상태를 변경하고 트랜잭션을 커밋하면 잠금을 해제한다.

그 이후 고객이 애그리거트를 구하게 되면 이미 배송상태이므로, 배송지를 변경할 수 없다.

선점 잠금은 보통 DBMS가 제공하는 해당 단위 잠금을 사용해서 구현한다. JPA EntityManager은 LockModeType을 인자로 받는 find() 메서드를 제공한다. 

```jsx
Order order = entityManager.find(Order.class,orderNo,LockModeType.PESSIMISTIC_WRITE)
```

```jsx
@Lock(LockModeType.PESSIMISTIC_WRITE)
```

**8.2.1 선점 잠금과 교착 상태**

 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야한다. 

EX) 

1. 스레드1 : A 애그리거트에 대한 선점 잠금 구함
2. 스레드2 : B 애그리거트에 대한 선점 잠금 구함
3. 스레드1 : B 애그리거트에 대한 선점 잠금 시도
4. 스레드2 : A 애그리거트에 대한 선점 잠금 시도

해당 예는 교착 상태에 빠진다. 스레드의 선점 잠금을 구한 다른 스레드가 선점 잠금을 시도했기 때문.

선점 잠금에 따른 교착 상태는 사용자 수가 많을 때 발생한다. 사용자 수가 많아지게 되면 스레드는 더 빠르게 증가하고, 시스템은 아무것도 할 수 없는 상태가 된다. → 교착 상태의 시간을 제한해줘야함

```jsx
eX) Spring Data JPA, @QueryHints 
```
